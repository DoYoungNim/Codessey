# 도커와 컨테이너 기술 가이드

## 1. 가상머신과 컨테이너의 차이

### 가상머신 (Virtual Machines)
- **정의**: 물리적 하드웨어를 추상화하여 하나의 서버를 여러 서버로 전환하는 기술
- **특징**:
  - 하이퍼바이저를 통해 단일 머신에서 여러 VM이 실행됨
  - 각 VM은 운영체제의 전체 복사본, 애플리케이션, 필요한 바이너리 및 라이브러리를 포함
  - 크기가 수십 GB에 달함
  - 부팅 속도가 느림

### 컨테이너 (Containers)
- **정의**: 애플리케이션 계층에서의 추상화로, 코드와 종속성을 함께 패키징하는 기술
- **특징**:
  - 여러 컨테이너가 동일한 머신에서 실행되며 다른 컨테이너와 OS 커널을 공유
  - 각각 사용자 공간에서 격리된 프로세스로 실행
  - VM보다 적은 공간 차지 (컨테이너 이미지는 일반적으로 수십 MB 크기)
  - 더 많은 애플리케이션을 처리할 수 있으며 더 적은 VM과 운영체제 필요

### 주요 차이점
| 구분 | 가상머신 | 컨테이너 |
|------|----------|----------|
| 가상화 대상 | 하드웨어 | 운영체제 |
| 크기 | 수십 GB | 수십 MB |
| 부팅 시간 | 느림 | 빠름 |
| 리소스 효율성 | 낮음 | 높음 |
| OS 공유 | 불가능 | 가능 |

## 2. 컨테이너와 이미지의 차이

### 컨테이너 이미지 (Container Image)
- **정의**: 애플리케이션을 실행하는 데 필요한 모든 것이 포함된 가볍고 독립적이며 실행 가능한 소프트웨어 패키지
- **구성 요소**:
  - 코드
  - 런타임
  - 시스템 도구
  - 시스템 라이브러리
  - 설정

### 컨테이너 (Container)
- **정의**: 코드와 모든 종속성을 패키징하는 소프트웨어의 표준 단위
- **실행 상태**: 컨테이너 이미지가 런타임에 실행될 때 컨테이너가 됨

### 관계
- **이미지 → 컨테이너**: 도커 컨테이너의 경우, 이미지가 Docker Engine에서 실행될 때 컨테이너가 됨
- **이미지는 템플릿**, **컨테이너는 실행 중인 인스턴스**

## 3. 컨테이너 런타임의 정의

### 컨테이너 런타임이란?
컨테이너 런타임은 컨테이너가 클라우드 네이티브 환경에서 실행되기 위해 필요한 모든 도구와 기능을 제공하는 소프트웨어입니다.

### 주요 기능
- 컨테이너 이미지를 실행 가능한 컨테이너로 변환
- 컨테이너의 생명주기 관리 (생성, 시작, 중지, 삭제)
- 리소스 격리 및 보안 제공
- 네트워킹 및 스토리지 관리

### 특징
- 운영체제 수준의 가상화 제공
- cgroups와 namespaces 같은 Linux 프리미티브 활용
- OCI (Open Container Initiative) 표준 준수

## 4. CNCF Landscape 기반 컨테이너 런타임 종류

### 1. containerd
- **개발**: Docker에서 CNCF에 기부
- **특징**: 
  - 업계 표준 컨테이너 런타임
  - runc를 활용
  - 단순성, 견고성, 이식성을 중시
  - Docker Engine의 핵심 컨테이너 런타임

### 2. CRI-O
- **개발**: Red Hat 주도
- **특징**:
  - Kubernetes를 위해 특별히 설계
  - OCI 호환
  - Kubernetes v1.24에서 표준화
  - 경량화된 컨테이너 런타임

### 3. runc
- **개발**: Docker에서 OCI에 기부
- **특징**:
  - OCI 런타임 사양의 참조 구현
  - 저수준 컨테이너 런타임
  - 다른 고수준 런타임들의 기반이 됨

### 추가 런타임
- **Kata Containers**: VM 기반 보안 강화 런타임
- **gVisor**: Google의 사용자 공간 커널을 사용하는 런타임
- **Firecracker**: AWS의 마이크로VM 기반 런타임

## 5. 도커 이미지의 레이어

### 레이어 구조
도커 이미지는 여러 레이어가 스택처럼 쌓여서 구성됩니다. 각 레이어는 이전 레이어의 상단에 적용된 파일시스템 변경 사항의 집합입니다.

### 레이어의 특징

#### 1. 불변성 (Immutable)
- **생성 후 변경 불가**: 레이어가 생성되면 변경할 수 없습니다
- **재사용 가능**: 동일한 레이어는 여러 이미지에서 공유됩니다

#### 2. 계층적 구조
- **순차적 적용**: 레이어들이 순서대로 적용되어 최종 이미지 형성
- **델타 방식**: 각 레이어는 파일 추가, 제거, 수정을 나타냄

#### 3. Dockerfile과의 관계
```dockerfile
FROM ubuntu:20.04        # 기본 레이어
RUN apt-get update       # 새로운 레이어 생성
COPY app.py /app/        # 새로운 레이어 생성
RUN pip install flask    # 새로운 레이어 생성
```
- **각 명령어마다 새 레이어 생성**
- **빈 레이어가 생성될 수도 있음**

### 레이어의 장점

#### 1. 효율적인 저장소 사용
- **중복 제거**: 동일한 레이어는 한 번만 저장
- **공간 절약**: 베이스 이미지 레이어를 여러 이미지가 공유

#### 2. 빠른 이미지 빌드
- **캐시 활용**: 변경되지 않은 레이어는 재사용
- **증분 빌드**: 변경된 레이어만 다시 빌드

#### 3. 효율적인 배포
- **레이어별 전송**: 필요한 레이어만 다운로드
- **병렬 다운로드**: 여러 레이어를 동시에 다운로드 가능

### 레이어 최적화 방법

#### 1. 명령어 최소화
```dockerfile
# 비효율적
RUN apt-get update
RUN apt-get install -y package1
RUN apt-get install -y package2

# 효율적
RUN apt-get update && \
    apt-get install -y package1 package2
```

#### 2. .dockerignore 사용
- 불필요한 파일을 이미지에서 제외
- 레이어 크기 최소화

#### 3. 멀티스테이지 빌드
- 빌드용 도구를 최종 이미지에서 제외
- 최종 이미지 크기 최소화

### Union File System
- **레이어 통합**: Union FS를 통해 여러 레이어를 하나의 파일시스템으로 통합
- **Copy-on-Write**: 컨테이너 실행 시 쓰기 가능한 레이어 추가
- **효율적인 스토리지**: 중복된 파일을 물리적으로 복사하지 않음

### 레이어 확인 방법
```bash
# 이미지 히스토리 확인
docker history <image_name>

# 이미지 상세 정보 확인
docker inspect <image_name>

# 레이어 구조 시각화
docker image inspect <image_name> | jq '.[].RootFS.Layers'
```

이러한 레이어 구조를 통해 도커는 효율적인 이미지 관리, 빠른 배포, 그리고 스토리지 최적화를 달성합니다.